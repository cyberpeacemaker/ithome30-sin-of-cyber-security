# 【19】資安的原罪 ch.3-3.a 密碼與身分驗證

---

## 什麼是身分驗證?

Authentication（身分驗證）是資訊安全中的一個重要機制，用來**確認一個使用者是否真的是他所聲稱的那個人**。簡單來說，就是系統在讓你進入之前，先確認「你是誰」。

* **Something You Know**

  * Passwords, PINs
* **Something You Have**

  * Smart cards, OTP tokens, security keys
* **Something You Are**

  * Biometrics (fingerprint, face recognition)
* **Somewhere You Are / Behavioral Biometrics**

  * IP-based/location-based authentication

> ⚠️ 注意：不要將 **Authentication（身分驗證）** 和 **Authorization（授權）** 搞混！
> * **Authentication** 是確認「你是誰」。
> * **Authorization** 是在確認你的身分之後，決定「你可以做什麼」。

舉個例子來說：
當你登入一個網站時，系統透過身分驗證確認你是某位使用者（Authentication）；接著根據你的身分判斷你是否有權限觀看某些頁面或資料（Authorization）。

## 常見的身分驗證方式

最常見的身分驗證方式就是 **密碼**。當你輸入帳號與密碼時，系統會檢查這組資訊是否與資料庫中的記錄相符，來判斷是否允許你登入。

除了密碼，還有許多其他的驗證方式，例如：

圖像密碼 PIN
* **生物辨識**：例如指紋、臉部辨識、虹膜掃描等。
* **安全憑證或智慧卡**：常見於企業或政府機構的安全應用中。


## **現代的替代方案與強化措施**

TODO: 密碼管理工具

為了提升使用者帳戶的安全性，現代的身份驗證技術逐漸超越傳統密碼的做法，以下是幾種常見且有效的現代替代方案與增強技術：

### **雙重驗證（2FA，Two-Factor Authentication）**

雙重驗證是指在輸入密碼後，還需要透過另一個獨立的驗證方式來確認使用者的身份，增加安全層級。常見的第二層驗證方式包括：

* **簡訊驗證碼（SMS Codes）**：系統會發送一次性密碼（OTP）到使用者的手機。
* **驗證器應用程式（Authenticator Apps）**：如 Google Authenticator 或 Microsoft Authenticator，產生即時的一次性密碼。
* **硬體安全金鑰（Hardware Tokens）**：如 YubiKey 等實體設備，用來進行身份驗證。

### **多重驗證（MFA，Multi-Factor Authentication）**

多重驗證是指使用兩種以上類型的驗證方式來進行身份確認，安全性比 2FA 更高。驗證方式一般分為三種類型：

* **知道的東西（知識類）**：如密碼、PIN 碼。
* **擁有的東西（持有類）**：如手機、硬體金鑰。
* **本身的特徵（生物特徵類）**：如指紋、臉部辨識、聲音辨識等。

MFA 通常結合上述兩種或更多驗證方式，能有效降低帳號被盜的風險。

### **單一登入（SSO，Single Sign-On）**

單一登入是一種讓使用者只需登入一次，就能存取多個相關系統或服務的機制。它帶來的好處包括：

* 減少使用者需要記憶的帳號密碼數量
* 提高登入便利性與效率
* 降低密碼重複使用所帶來的安全風險

SSO 常應用於企業內部系統或教育機構的整合平台中。

### **無密碼驗證（Passwordless Authentication）**

無密碼驗證是近年來快速興起的趨勢，它完全省略傳統密碼的使用，改用更安全、便利的驗證方式，如：

* **生物辨識技術**：如指紋掃描、臉部辨識、虹膜辨識等。
* **魔法連結（Magic Links）**：系統寄送一次性登入連結到使用者電子郵件，點擊即可登入。
* **裝置型驗證**：透過已註冊的可信裝置（如手機）確認登入請求，例如 Apple 的 Face ID 或 Windows Hello。

這些方法不僅能提升安全性，也能大幅改善使用者體驗。

---

## 雜湊（Hashing）

**雜湊（Hashing）** 是一種將資料（例如密碼）轉換成固定長度字串的單向演算法，常用來作為**密碼保護的基本機制**。這種轉換**無法逆推**，意味著雖然可以從密碼產生雜湊值，但幾乎不可能從雜湊值還原出原始密碼。這使得即使資料庫被駭，攻擊者也無法看到真正的密碼。


###　**加入鹽值（Salting）**

* 為每個密碼加入隨機字串（salt）再進行雜湊
* 防止使用彩虹表（預先計算好的雜湊對照表）攻擊
* 即使兩個使用者的密碼相同，加鹽後雜湊結果也會不同


### **進階：加入椒值（Peppering）**

* 額外加入一個隱藏的秘密字串（pepper）
* 通常儲存在程式碼或環境變數中，而非資料庫
* 進一步增加破解難度


**雜湊 vs 加密**

| 比較項目 | 雜湊（Hashing） | 加密（Encryption） |
| ---- | ----------- | -------------- |
| 可逆性  | 否（一旦雜湊無法還原） | 是（用金鑰可解密）      |
| 用途   | 密碼儲存        | 資料保密傳輸         |

* 密碼儲存只應使用雜湊，而非加密


**常見錯誤**

* 只儲存未加鹽的雜湊值
* 使用不適合的快速雜湊演算法（如 SHA-256）
* 重複或可預測的鹽值

> ⚠️ 建議使用專門為密碼設計的雜湊演算法，如 **bcrypt、scrypt 或 Argon2**


---

## **Session（會話）機制說明**

### **1. 為什麼需要 Session？**

* HTTP 是無狀態的（stateless）協議，這表示每個請求彼此獨立，伺服器不會記得上一個請求的使用者是誰。
* 為了讓伺服器能夠「記住使用者的身份」，通常會使用 Session 機制。

### **2. Session 的運作方式**

1. 使用者登入後，伺服器產生一個唯一的 Session ID。
2. 這個 Session ID 通常會透過「Cookie」的方式傳回給使用者的瀏覽器。
3. 在後續的每一次請求中，瀏覽器會自動帶上這個 Cookie。
4. 伺服器藉由 Session ID 來識別是哪一位使用者，並根據對應的 Session 資料提供服務。

* Session ID 通常會對應到伺服器端儲存的資訊，如登入狀態、使用者偏好設定等。
* Session 通常會設定「過期時間」，可透過使用者主動登出或閒置一段時間自動失效。

#### 3. **Session vs Token-Based Authentication**

* Sessions: Server stores session data.
* Tokens (like JWT): Client stores token, server stateless.
* When to use each.

### **4. Session 被冒用的風險與攻擊方式**

* 攻擊者可能透過惡意程式碼（例如 JavaScript）來竊取用戶瀏覽器中的 Cookie，進而取得 Session ID。
* 有些攻擊方式像是 **Adversary-in-the-Middle（中間人攻擊）**，攻擊者建立惡意代理伺服器來攔截並取得使用者的 Session Cookie。
* 開源工具如 **Evilginx2** 和 **Muraena** 就是專門設計來進行這類攻擊的工具，常見於釣魚攻擊場景中。
* 一旦攻擊者成功取得有效的 Session Cookie，就能「假冒使用者身份」登入系統，造成嚴重安全風險。[^1]

### **3. Session 與 Token-Based Authentication 的差異**

| 項目     | Session-Based 驗證              | Token-Based 驗證（如 JWT）               |
| ------ | ----------------------------- | ----------------------------------- |
| 狀態儲存   | 伺服器端儲存 Session 資料             | Token 儲存在客戶端，伺服器無需儲存狀態（Stateless）   |
| 資料儲存位置 | Session ID 通常存在 Cookie 中      | Token（JWT）可存在 Cookie 或 LocalStorage |
| 安全性管理  | 可以在伺服器端控制失效（例如：登出時刪除 Session） | Token 通常有過期時間，但一旦發出就無法撤回            |


### **5. 小結**

* **Session** 是為了解決 HTTP 無狀態的限制，透過在客戶端儲存 Session ID，讓伺服器能記住使用者。
* Cookie 是 Session 最常見的儲存方式，但也容易成為攻擊目標。
* 對 Session 的保護措施（例如使用 HTTPS、設置 HttpOnly 與 Secure 屬性、定期更新或失效 Session）是防範攻擊的關鍵。

---

## # OAuth 是什麼？

### 🔐 簡單解釋

* **OAuth 是用來授權的標準**（不是用來驗證身份！）。
* 讓使用者可以**授權應用程式存取特定資料**，而不必提供密碼。
* 像一張「許可證」，讓應用程式存取某些資料（但不是全部）。
* 使用者有掌控權：可以選擇要開放什麼、開放多久。
* 密碼不外洩，風險更低。
* 常見例子：
  * 「使用 Google 登入」
  * 「允許這個應用程式存取你的 Twitter 帳戶」

### 🚪 用場景來想像：

你住飯店想用健身房，
健身房**不問你是誰，只看你有沒有飯店發的門卡。**
門卡上寫著：「✅ 這位住客有健身房使用權限」→ 你就可以進去了。

OAuth 的原理類似：
應用程式不用知道你密碼，只要平台（像 Google）給它一把「授權憑證」。

### 💡 OAuth 解決的問題

例如：一個相簿應用想讀取你 Google Drive 的照片。
你不需要給它 Google 密碼，流程會是：

1. 點「使用 Google 登入」
2. Google 會問你：「允許這個應用程式存取你的照片嗎？」
3. 你選擇允許 → Google 發出一個「Token（存取憑證）」
4. 應用程式就只可以讀你的照片，不能看郵件或聯絡人。

✅ 你沒洩露密碼
✅ 可以隨時取消授權

### 🔄 與身份驗證相關：OpenID Connect（OIDC）

* **OIDC = OAuth 2.0 + 身份層**
* 加入「你是誰」的資訊（如名字、Email、頭像）
* 才能實現「登入 Google 帳號」這種功能

### 🧠 總結表

| 名稱                 | 解釋                                  |
| ------------------ | ----------------------------------- |
| **OAuth**          | 安全讓 App 存取你其他帳號的一部分資料（如 Google 的照片） |
| **Token**          | 一把限制存取範圍的「鑰匙」                       |
| **OpenID Connect** | 在 OAuth 基礎上加入「身份資訊」，可用來做登入功能        |


---

## SIN

### 5. **Threats and Attacks on Authentication Systems**

* Brute-force and dictionary attacks
* Phishing and credential theft
* Credential stuffing
* Keyloggers and spyware
* Man-in-the-middle (MITM) attacks

### Complex password not practical
## PassWord
美國國防部綠皮書 密碼該由機器利用演算法生成 [^連結](https://apps.dtic.mil/sti/citations/ADA425705)

每個獨立 不重複 複雜的密碼 還要背下來 不切實際 
多台電腦與不同網站上重複利用相同的密碼

## Password decrypted
暴力破解 字典攻擊 撞庫攻擊(TODO:MS用戶密碼潑灑?1240/27)
雜湊密碼破解 反向猜密碼 比對雜湊結果
量子 雲端計算
花多少時間破解 > 花多少錢破解

## MFA
信任此裝置

## Password Leak
儲存密碼文件外洩 密碼管理工具外洩
從系統中取得加密密碼清單，也不需要破解了
key logger

## Biometric
生物驗證失靈
仰賴密碼

## ID Verification
驗證功能程式寫的漏洞百出 沒用 EX: T MOBILE 2005 拉夸 希爾頓
Session 


d custom password retrieval tools on victims.[47][3] They have also dumped the LSASS process memory u


### 🔥 What is Session Hijacking?

Session hijacking occurs when an attacker steals or guesses the session identifier (usually a cookie) and uses it to access the victim’s active session. Since the server trusts the session ID, the attacker is treated as the legitimate user — no additional authentication needed.

# ⚠️ Session fixation vs session hijacking (short)

* **Fixation**: attacker sets/controls the session ID before login and reuses it after victim authenticates.
* **Hijacking**: attacker steals an already-active session identifier and uses it.

## Replay attack
Why it matters

What a replay attack is (1‑line): an attacker captures a valid authentication message (e.g., a login request or auth token) and resends it later to impersonate the user.

Why relevant to “password & authentication”: many modern attacks aren’t against the hashed password in your database but against the authentication exchange — e.g., stolen tokens, intercepted login requests on an insecure network, or reuse of one‑time responses.

When to include it

Include replay attacks if your talk covers any of:

Transport or network layer (HTTP, TLS, plain HTTP).

Session tokens, cookies, JWTs, bearer tokens, or API keys.

Challenge–response flows, OTPs, or authentication protocols (Kerberos, SRP, NTLM, etc.).

Multi‑factor or passwordless flows where tokens/one-time codes are used.


[^1]: https://attack.mitre.org/techniques/T1539/




