# 【19】資安的原罪 ch.3-3.a 密碼與身分驗證

本章見證保護和驗證使用者身分的機制。

---

## 什麼是身分驗證?

Authentication（身分驗證）是資訊安全中的一個重要機制，用來**確認一個使用者是否真的是他所聲稱的那個人**。簡單來說，就是系統在讓你進入之前，先確認「你是誰」。

> ⚠️ 注意：不要將 **Authentication（身分驗證）** 和 **Authorization（授權）** 搞混！
> * **Authentication** 是確認「你是誰」。
> * **Authorization** 是在確認你的身分之後，決定「你可以做什麼」。

舉例來說：當你登入一個網站時，系統會透過身分驗證（Authentication）確認你是某位使用者；接著再根據你的身分，判斷你是否有權限存取特定頁面或資料（Authorization）。

## 常見的身分驗證方式

### **・你知道的東西**（Knowledge-based）

* 密碼（Password）
* PIN 碼
* 圖像密碼（Pattern Lock）

### **・你擁有的東西**（Possession-based）

* 安全憑證（Security Token）
* 智慧卡（Smart Card）
* 一次性密碼（OTP）裝置
* 實體安全金鑰（如 YubiKey）

### **・你是的特徵**（Inherence-based）

* 指紋
* 臉部辨識
* 虹膜掃描
* 聲音辨識等

---

## **現代改良與強化措施**

為了提升帳戶安全性，現代的身分驗證技術已逐漸超越傳統「密碼為主」的做法。以下是幾種常見且有效的現代替代方案與增強技術：

### 🔐 **密碼管理工具（Password Manager）**

密碼管理工具可協助使用者建立、儲存並自動填入高強度且唯一的密碼，能有效降低因密碼重複或強度不足所帶來的資安風險。其常見功能包括：

* **自動產生強密碼**：依照使用者設定產生隨機、複雜密碼。
* **加密儲存**：將帳戶資訊加密保存於本地或雲端。
* **跨平台同步**：支援多裝置（電腦、手機、平板）間密碼同步。
* **自動填寫登入表單**：提升使用便利性與效率。

### 📱 **限制登入裝置數量**

部分高安全性的系統會實施「單一裝置登入」限制，避免帳戶同時在多個裝置上被使用，以降低帳號被盜用或濫用的風險。

安全優點包括：

* **即時偵測異常登入行為**：多裝置同時登入時可即時封鎖或通知。
* **提升帳號掌控能力**：使用者可清楚掌握帳號的使用狀況。
* **防止帳號共用**：常見於串流媒體或企業系統，避免帳戶被多人共享。

### 🔒 **雙重／多重驗證（2FA / MFA）**

雙重驗證（2FA, Two-Factor Authentication）需在密碼之外，再提供另一種獨立驗證方式。多重驗證（MFA, Multi-Factor Authentication）則是使用兩種以上的驗證因子，安全性更高。

常見的第二驗證方式包括：

* **簡訊驗證碼（SMS Codes）**：發送一次性密碼（OTP）到使用者手機。
* **驗證器 App（Authenticator Apps）**：如 Google Authenticator、Microsoft Authenticator。
* **硬體安全金鑰（Hardware Tokens）**：如 YubiKey 等實體設備。


### 🚫 **無密碼驗證（Passwordless Authentication）**

無密碼驗證是一項日益普及的安全趨勢，完全不使用傳統密碼，而是透過更先進且安全的方式進行身分確認，例如：

* **生物辨識**：如指紋、臉部、虹膜辨識等。
* **魔法連結（Magic Links）**：系統傳送一次性登入連結至電子郵件，用戶點擊即可登入。
* **裝置型驗證**：透過已註冊的可信裝置進行驗證，例如 Apple Face ID、Windows Hello。

**FIDO 與 WebAuthn 標準**

現代無密碼驗證技術多採用 **FIDO（Fast Identity Online）聯盟** 推動的標準，提供強化的安全性與使用者體驗。這些標準已被 Google、Microsoft、Apple 等主流平台廣泛採用，能有效防範釣魚攻擊與帳號盜用。

* **FIDO2**：是一套無密碼驗證標準，結合 WebAuthn（Web 認證 API）與 CTAP（Client to Authenticator Protocol），支援以生物辨識、實體金鑰等方式進行安全登入。
* **WebAuthn**：是一種由 W3C 與 FIDO 聯盟共同制定的網頁驗證標準，允許網站使用瀏覽器 API 呼叫本地裝置（如指紋感測器或安全金鑰）進行身分驗證，無需輸入密碼。

---

## 雜湊（Hashing）

**雜湊（Hashing）** 是一種**單向演算法**，將輸入資料（例如密碼）轉換為固定長度的字串（雜湊值）。這種轉換**不可逆**，也就是無法從雜湊值還原出原始資料。

> 🔐 常用於密碼儲存，目的是就算資料庫被入侵，攻擊者也無法直接得知使用者的密碼。


### 🧂 加入鹽值（Salting）

* 為每筆密碼**加入隨機字串**（salt）後再進行雜湊。
* 有效防止**彩虹表攻擊**（利用預先計算好的雜湊對照表來反查密碼）。
* 就算兩位使用者密碼相同，加鹽後的雜湊值也會不同。


### 🌶️ 加入椒值（Peppering）

* 額外加入一段**隱藏的固定秘密字串（pepper）**。
* Pepper 不應儲存在資料庫中，通常放在**應用程式碼或環境變數中**。
* 增加攻擊者無法靠單一資料庫就還原密碼的難度。

### ⚠️ 常見錯誤做法

* ❌ **只儲存未加鹽的雜湊值**，容易遭受預計算攻擊。
* ❌ **使用過快的雜湊演算法**（如 SHA-1 / SHA-256），無法有效延緩暴力破解。
* ❌ **使用固定或可預測的鹽值**，無法真正達到防護目的。

### 🔐 雜湊 vs. 加密

| 比較項目 | 雜湊（Hashing） | 加密（Encryption） |
| ---- | ----------- | -------------- |
| 可逆性  | 否（不可逆）      | 是（可用金鑰解密）      |
| 主要用途 | 密碼儲存        | 敏感資料的傳輸與保存     |
| 金鑰需求 | 不需要         | 需要加密／解密金鑰      |

> ⚠️ **密碼儲存應使用雜湊，不應使用加密**。
> 加密是為了之後可以還原，而雜湊是為了無法還原。

---

## **Session（會話）機制說明**

### 🔍 **為什麼需要 Session？**

**HTTP 是無狀態（stateless）協議**，每一次請求都是獨立的，伺服器不會記得使用者之前的操作。為了讓伺服器能夠「記住使用者的身分」，就需要透過 **Session 機制**來維持使用者狀態。

### ⚙️ **Session 的運作方式**

1. 使用者登入後，伺服器會產生一組唯一的 **Session ID**。
2. 該 Session ID 會透過 **Cookie** 傳回給使用者的瀏覽器。
3. 接下來每一次請求，瀏覽器會自動附帶這個 Cookie。
4. 伺服器根據 Session ID 找到對應的 Session 資料，判斷使用者身分並提供對應服務。

> Session ID 對應的資料通常包含：登入狀態、使用者偏好、權限資訊等。
> 為了安全，Session 通常會設定 **過期時間**，並可在使用者閒置一段時間或登出時自動失效。

### 🆚 **會話式認證 vs 基於令牌的認證**

| 項目     | 會話式認證（Session-based）      | 令牌式認證（Token-based，如 JWT）         |
| ------ | ------------------------- | -------------------------------- |
| 狀態儲存   | 伺服器儲存使用者 Session 資料       | 無狀態（Stateless），不需伺服器儲存驗證資料       |
| 資料存放位置 | Session ID 通常儲存在 Cookie 中 | Token 可儲存在 Cookie 或 LocalStorage |
| 控制與撤銷  | 可由伺服器主動失效（如強制登出）          | 發出後無法撤銷，僅靠過期時間失效                 |
| 跨系統適用性 | 通常適用於同一伺服器架構              | 較容易用於分散式架構或微服務系統                 |

> 🔐 實務上也可結合兩種方式：使用短期 Token + 長期 Session 管理，提高彈性與安全性。

### ⚠️ **Session 遭冒用的風險與攻擊方式**

Session 若未妥善保護，可能遭到以下攻擊：

* **XSS 攻擊**：若網站有跨站腳本漏洞，攻擊者可注入 JavaScript 窃取瀏覽器中的 Session Cookie。
* **中間人攻擊（Adversary-in-the-Middle）**：攻擊者透過惡意 Wi-Fi 或代理伺服器，攔截 Cookie 資訊。
* **釣魚攻擊工具**：如 [Evilginx2](https://github.com/kgretzky/evilginx2)、[Muraena](https://github.com/muraenateam/muraena) 等，可模擬合法登入頁面並轉發使用者 Session Cookie。

> 一旦 Session Cookie 被竊取，攻擊者就能**假冒使用者身份登入系統**，造成嚴重資安風險。

---

## OAuth 是什麼？

**OAuth**（Open Authorization）是一種**授權標準**，用來讓應用程式**在不需取得使用者密碼的情況下，存取使用者授權的資料**。像是：

* 使用第三方帳號登入（例如「使用 Google 登入」）
* 授權應用程式存取你在某平台上的特定資料（如 Google Drive 的照片）

> ❗ OAuth 用來授權（Authorization），**不是**用來身份驗證（Authentication）。

### 📌 OAuth 的核心概念

* 使用者**不需將密碼提**供給第三方應用程式。
* 應用程式透過「授權伺服器」取得一個 **Token（存取憑證）**。
* Token 就像一把有限功能的鑰匙，只能存取特定資源。
* 使用者**可隨時撤銷授權**，保障個人隱私與安全。

### 🔄 與身份驗證相關：OpenID Connect（OIDC）

**OIDC** 是建立在 OAuth 2.0 基礎上的延伸協議，加入了「身份層」，可用於「登入」功能。

| 名稱                 | 說明                                  |
| ------------------ | ----------------------------------- |
| **OAuth**          | 授權應用程式存取某部分帳號資料（如 Google Drive 的照片） |
| **Access Token**   | 限定權限的「鑰匙」，用來存取資源資料                  |
| **OpenID Connect** | OAuth 加上「身份資訊」，可用來驗證使用者並實作登入功能      |

### ✅ 小結

| 功能   | OAuth                         | OpenID Connect                 |
| ---- | ----------------------------- | ------------------------------ |
| 主要用途 | 授權（授權應用程式存取資源）                | 身份驗證 + 授權（用於登入）                |
| 傳回資訊 | Access Token（和 Refresh Token） | Access Token + ID Token（含身份資訊） |
| 使用場景 | API 資料授權存取                    | 「使用 Google 登入」這類登入功能           |

---

## 原罪

### 1. 密碼設定的困境

現代使用者往往同時擁有多個裝置與眾多服務／應用。要求使用者為每個帳號設定獨立且複雜的強密碼，並長期妥善保存，**在實務上難以執行。**

### 2. 時間壁壘的消失

不論密碼多複雜，只要擁有**足夠時間都能破解**。隨著量子、雲端計算的出現，仰賴時間成本的安全將不復存在。

### 3. 儲存與傳輸的必要

密碼除了儲存在使用者腦海，使用上也一定**必須儲存在別處和進行傳輸**。而這個情況就一定會有遭受攻擊的風險，像是儲存在檔案或密碼管理器中的資料外洩、在不安全的通訊中遭受中間人攻擊、端點被植入鍵盤記錄器或間諜軟體、透過記憶體傾印取得明文憑證等。

### 4. 身分驗證的機制

不論仰賴什麼認證機制，只要不是**本人親身驗證**，都無法阻擋被冒充的問題。像是Session劫持、重播攻擊、信任此裝置等問題。讓攻擊者無須擁有密碼資訊，也能冒充使用者。


[^1]: https://attack.mitre.org/techniques/T1539/
[^2]: https://www.ithome.com.tw/news/169548

