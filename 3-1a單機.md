# 【10】資安的原罪 ch.3-1.a 單機電腦

本章見證電腦的誕生與早期資安的研究。

---

## 電腦發展過程的關鍵奠基石

這裡介紹幾個構成當代電腦雛形的重要節點。

### 獨立電腦 (1940年代)

第一台真正的電子電腦 **ENIAC (Electronic Numerical Integrator and Computer)** 是在1940年代開發的，並且標誌著計算歷史中的一個關鍵時刻。它是一台龐大、房間大小的機器，能夠每秒進行數千次的運算。

當時，使用者必須將程式打孔在實體卡片上，並將整批卡片交給系統操作員處理，這是一個緩慢且非互動式的體驗。**想改變程序需透過對物理硬體重新接線**的方式。

### 存儲程式概念 (1945年)

在1945年，*John von Neumann* 在他的報告《First Draft of a Report on the EDVAC》中提出了 **存儲程式概念（stored-program concept）**。這一模型成為了現代計算的基礎。

核心概念：

* **程序指令 (program instructions) 和數據 (data) 都存儲在同一記憶體中**。
* CPU 以抓取數據的方式抓取指令。
* 電腦可以通過將新**程式碼載入記憶體來重編程 (reprogrammed)**，不再像ENIAC需要重新接線。

這一創新大大提高了靈活性，並為互動式計算鋪平了道路。

### 編譯器（1950年代）

編譯器（Compiler）是一個將**高階程式語言翻譯成機器語言**或中間代碼（如Java的字節碼）的軟體工具。這一過程對於現代電腦系統的運作至關重要，因為它讓人類可以用易懂的語言編寫程式，而電腦則能夠理解並執行這些程式。


### 分時系統(1961年)

分時系統 (Compatible Time-Sharing SystemS) 是在1961年由麻省理工學院（MIT）開發的，它是第一批允許 多使用者 (multiple users) 同時訪問單一電腦的操作系統之一，通過將 CPU **時間分配給不同的使用者**來實現——這個概念被稱為**時間共享（time-sharing）**。

這一變革取代了緩慢的批次處理，使得互動計算 (interactive computing)成為可能，改善了系統資源的利用和使用者體驗，讓使用者能夠透過終端(terminals)跟電腦互動。

### UNIX (1969)

UNIX 是由 *Ken Thompson* 和 *Dennis Ritchie* 在貝爾實驗室（Bell Labs）開發的作業系統。它的設計哲學非常注重**簡潔性**和**模組化**，即透過小型的工具來實現強大的功能，並且支援多使用者和多任務處理。UNIX的誕生在很大程度上改變了電腦的使用方式，成為許多**現代作業系統的基礎**，包括Linux和macOS。

---

## 資訊安全的發展嘗試

隨著電腦的發展，安全性的議題也開始浮出，這裡介紹早期學者的對資安的一些研究嘗試。

### Bell–LaPadula 模型與基本安全定理 (1970年代)

由 *David Elliott Bell* 和 *Leonard J. LaPadula* 為美國國防部開發的 **Bell–LaPadula model** 是一種專注於 **機密性 (confidentiality)** 的正式訪問控制模型 (access control model)。

#### 核心概念：

* 主體 (Subjects)：使用者、進程
* 對象 (Objects)：檔案、資料庫
* 安全等級 (Security levels)：未分類、機密、秘密、絕密

#### 主要規則：

* **簡單安全性屬性 (Simple Security Property)** （無法向上讀取）：使用者無法讀取其許可等級以上的數據。
* **\*屬性 (Star Security Property)**（無法向下寫入）：使用者無法寫入數據到較低許可等級的地方。

#### 基本安全定理：

> **如果一個系統在安全狀態下啟動，並且所有過程中的轉換都遵守安全規則，那麼該系統將保持安全。**

### 形式驗證 (1980年代)

在1983年，美國國防部的**橘皮書** TCSEC（**Trusted Computer System Evaluation Criteria**，信任電腦系統評估標準）中，正式介紹了**形式驗證**（**Formal Verification**）。

**形式驗證**是一種數學方法，用於證明系統是否按照其規範進行運作，特別是在軍事、醫療和航空航天等關鍵應用領域中，對系統的安全性和可靠性進行驗證。

#### 形式驗證的運作方式：

形式驗證通常包括以下幾個關鍵步驟：

1. **規範定義**：定義系統所需的屬性（例如，存取控制政策、避免信息洩漏等）。
2. **建模**：建立系統的正式模型（通常使用形式邏輯或有限狀態機等方法）。
3. **證明**：利用數學證明技術，如模型檢查（Model Checking）或定理證明（Theorem Proving），來驗證系統是否滿足其規範。
4. **驗證**：確保模型的行為與系統的實際運行一致。

---

## 「原罪」

### 1.Shared Memory for Code & Data: A Double-Edged Sword

The innovation of sharing memory between **code and data** increased efficiency but also introduced a major vulnerability:

> If the system cannot distinguish between “data to be processed” and “code to be executed,” malicious input can be **executed as code** — the foundation of many modern attacks.

### 2 Covert Channels & the Confinement Problem

硬體物理的運作遵循物理的法則，隱密隧道的問題將永遠存在，而現在隨著行動運算、雲端運算的盛行，這將會是未來恐怕不德不在面對的問題
TODO: A49
**Covert channels** are unintended communication paths that bypass normal security controls — often leveraging hardware behavior.

* **Confinement Problem**: It’s impossible to guarantee that a program cannot leak data to the outside world.
* These channels **don’t rely on software vulnerabilities** and are difficult to detect or eliminate.

TODO:
As mobile and cloud computing become dominant, these threats become more serious.

### 3 Operating System Trust & Compiler Backdoors

TODO: Multics編譯器問題 湯普森不得不成親沒有將後門導入UNIX
All software must ultimately run on an **operating system**, which itself must be compiled — and **compilers can be subverted**.

* **Ken Thompson** (creator of UNIX) demonstrated in his famous talk *“Reflections on Trusting Trust”* how a compiler could insert a **backdoor** into any program it compiles — even into itself — in a way that is **invisible** to code reviewers.
* Unless you write **everything from scratch** (including your compiler), you can never fully trust your system.
* Real-world example: **Eric Allman’s `sendmail`** accidentally left in a backdoor that was later exploited by the **Morris Worm**.

TODO:
### 4 The Cost of Verified Security

While **mathematically verified security** is ideal, it is:

* **Time-consuming**
* **Expensive**
* Often **commercially unviable**

Example:
The **SCOMP computer**, one of the few systems to achieve **A1-level certification** (highest under TCSEC), sold fewer than **30 units** worldwide.
Meanwhile, only around **200 experts** globally are capable of evaluating software to that standard.



[^1]: https://ieeexplore.ieee.org/document/601735